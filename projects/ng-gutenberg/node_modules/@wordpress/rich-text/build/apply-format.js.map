{"version":3,"sources":["@wordpress/rich-text/src/apply-format.js"],"names":["replace","array","index","value","slice","applyFormat","format","startIndex","start","endIndex","end","formats","activeFormats","newFormats","startFormat","type","indexOf","position","Infinity","filter","length","splice"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\n\nimport { find, reject } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\nfunction replace( array, index, value ) {\n\tarray = array.slice();\n\tarray[ index ] = value;\n\treturn array;\n}\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {Object} value        Value to modify.\n * @param {Object} format       Format to apply.\n * @param {number} [startIndex] Start index.\n * @param {number} [endIndex]   End index.\n *\n * @return {Object} A new value with the format applied.\n */\nexport function applyFormat(\n\tvalue,\n\tformat,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// The selection is collapsed.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = find( newFormats[ startIndex ], { type: format.type } );\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\tconst index = newFormats[ startIndex ].indexOf( startFormat );\n\n\t\t\twhile ( newFormats[ startIndex ] && newFormats[ startIndex ][ index ] === startFormat ) {\n\t\t\t\tnewFormats[ startIndex ] =\n\t\t\t\t\treplace( newFormats[ startIndex ], index, format );\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile ( newFormats[ endIndex ] && newFormats[ endIndex ][ index ] === startFormat ) {\n\t\t\t\tnewFormats[ endIndex ] =\n\t\t\t\t\treplace( newFormats[ endIndex ], index, format );\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Determine the highest position the new format can be inserted at.\n\t\tlet position = +Infinity;\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tif ( newFormats[ index ] ) {\n\t\t\t\tnewFormats[ index ] = newFormats[ index ]\n\t\t\t\t\t.filter( ( { type } ) => type !== format.type );\n\n\t\t\t\tconst length = newFormats[ index ].length;\n\n\t\t\t\tif ( length < position ) {\n\t\t\t\t\tposition = length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewFormats[ index ] = [];\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tnewFormats[ index ].splice( position, 0, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\t// Always revise active formats. This serves as a placeholder for new\n\t\t// inputs with the format so new input appears with the format applied,\n\t\t// and ensures a format of the same type uses the latest values.\n\t\tactiveFormats: [\n\t\t\t...reject( activeFormats, { type: format.type } ),\n\t\t\tformat,\n\t\t],\n\t} );\n}\n"]}