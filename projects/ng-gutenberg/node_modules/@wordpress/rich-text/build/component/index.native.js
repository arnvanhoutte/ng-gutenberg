"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.RichText = void 0;

var _element = require("@wordpress/element");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _reactNativeAztec = _interopRequireDefault(require("react-native-aztec"));

var _reactNative = require("react-native");

var _lodash = require("lodash");

var _memize = _interopRequireDefault(require("memize"));

var _compose = require("@wordpress/compose");

var _data = require("@wordpress/data");

var _blocks = require("@wordpress/blocks");

var _htmlEntities = require("@wordpress/html-entities");

var _keycodes = require("@wordpress/keycodes");

var _url = require("@wordpress/url");

var _formatEdit = _interopRequireDefault(require("./format-edit"));

var _applyFormat = require("../apply-format");

var _getActiveFormat = require("../get-active-format");

var _getActiveFormats = require("../get-active-formats");

var _isEmpty2 = require("../is-empty");

var _create = require("../create");

var _split3 = require("../split");

var _toHtmlString = require("../to-html-string");

var _insert = require("../insert");

var _insertLineSeparator = require("../insert-line-separator");

var _removeLineSeparator = require("../remove-line-separator");

var _isCollapsed = require("../is-collapsed");

var _remove = require("../remove");

var _style = _interopRequireDefault(require("./style.scss"));

/*eslint no-console: ["error", { allow: ["warn"] }] */

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
var unescapeSpaces = function unescapeSpaces(text) {
  return text.replace(/&nbsp;|&#160;/gi, ' ');
};
/**
 * Calls {@link pasteHandler} with a fallback to plain text when HTML processing
 * results in errors
 *
 * @param {Function}  originalPasteHandler  The original handler function
 * @param {Object}  [options]     The options to pass to {@link pasteHandler}
 *
 * @return {Array|string}         A list of blocks or a string, depending on
 *                                `handlerMode`.
 */


var saferPasteHandler = function saferPasteHandler(originalPasteHandler, options) {
  try {
    return originalPasteHandler(options);
  } catch (error) {
    window.console.log('Pasting HTML failed:', error);
    window.console.log('HTML:', options.HTML);
    window.console.log('Falling back to plain text.'); // fallback to plain text

    return originalPasteHandler((0, _objectSpread2.default)({}, options, {
      HTML: ''
    }));
  }
};

var gutenbergFormatNamesToAztec = {
  'core/bold': 'bold',
  'core/italic': 'italic',
  'core/strikethrough': 'strikethrough'
};

var RichText =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2.default)(RichText, _Component);

  function RichText(_ref) {
    var _this;

    var value = _ref.value,
        multiline = _ref.__unstableMultiline,
        selectionStart = _ref.selectionStart,
        selectionEnd = _ref.selectionEnd;
    (0, _classCallCheck2.default)(this, RichText);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(RichText).apply(this, arguments));
    _this.isMultiline = false;

    if (multiline === true || multiline === 'p' || multiline === 'li') {
      _this.multilineTag = multiline === true ? 'p' : multiline;
      _this.isMultiline = true;
    }

    if (_this.multilineTag === 'li') {
      _this.multilineWrapperTags = ['ul', 'ol'];
    }

    _this.onSplit = _this.onSplit.bind((0, _assertThisInitialized2.default)(_this));
    _this.isIOS = _reactNative.Platform.OS === 'ios';
    _this.createRecord = _this.createRecord.bind((0, _assertThisInitialized2.default)(_this));
    _this.onChange = _this.onChange.bind((0, _assertThisInitialized2.default)(_this));
    _this.onEnter = _this.onEnter.bind((0, _assertThisInitialized2.default)(_this));
    _this.onBackspace = _this.onBackspace.bind((0, _assertThisInitialized2.default)(_this));
    _this.onPaste = _this.onPaste.bind((0, _assertThisInitialized2.default)(_this));
    _this.onFocus = _this.onFocus.bind((0, _assertThisInitialized2.default)(_this));
    _this.onBlur = _this.onBlur.bind((0, _assertThisInitialized2.default)(_this));
    _this.onTextUpdate = _this.onTextUpdate.bind((0, _assertThisInitialized2.default)(_this));
    _this.onContentSizeChange = _this.onContentSizeChange.bind((0, _assertThisInitialized2.default)(_this));
    _this.onFormatChange = _this.onFormatChange.bind((0, _assertThisInitialized2.default)(_this));
    _this.formatToValue = (0, _memize.default)(_this.formatToValue.bind((0, _assertThisInitialized2.default)(_this)), {
      maxSize: 1
    }); // This prevents a bug in Aztec which triggers onSelectionChange twice on format change

    _this.onSelectionChange = _this.onSelectionChange.bind((0, _assertThisInitialized2.default)(_this));
    _this.onSelectionChangeFromAztec = _this.onSelectionChangeFromAztec.bind((0, _assertThisInitialized2.default)(_this));
    _this.valueToFormat = _this.valueToFormat.bind((0, _assertThisInitialized2.default)(_this));
    _this.willTrimSpaces = _this.willTrimSpaces.bind((0, _assertThisInitialized2.default)(_this));
    _this.getHtmlToRender = _this.getHtmlToRender.bind((0, _assertThisInitialized2.default)(_this));
    _this.state = {
      activeFormats: [],
      selectedFormat: null,
      height: 0
    };
    _this.needsSelectionUpdate = false;
    _this.savedContent = '';
    _this.isTouched = false;
    _this.lastAztecEventType = null;
    _this.lastHistoryValue = value; // Internal values that are update synchronously, unlike props.

    _this.value = value;
    _this.selectionStart = selectionStart;
    _this.selectionEnd = selectionEnd;
    return _this;
  }
  /**
   * Get the current record (value and selection) from props and state.
   *
   * @return {Object} The current record (value and selection).
   */


  (0, _createClass2.default)(RichText, [{
    key: "getRecord",
    value: function getRecord() {
      var _this$props = this.props,
          start = _this$props.selectionStart,
          end = _this$props.selectionEnd;
      var value = this.props.value; // Since we get the text selection from Aztec we need to be in sync with the HTML `value`
      // Removing leading white spaces using `trim()` should make sure this is the case.

      if (typeof value === 'string' || value instanceof String) {
        value = value.trimLeft();
      }

      var _this$formatToValue = this.formatToValue(value),
          formats = _this$formatToValue.formats,
          replacements = _this$formatToValue.replacements,
          text = _this$formatToValue.text;

      var activeFormats = this.state.activeFormats;
      return {
        formats: formats,
        replacements: replacements,
        text: text,
        start: start,
        end: end,
        activeFormats: activeFormats
      };
    }
    /**
     * Creates a RichText value "record" from the current content and selection
     * information
     *
     *
     * @return {Object} A RichText value with formats and selection.
     */

  }, {
    key: "createRecord",
    value: function createRecord() {
      var value = (0, _objectSpread2.default)({
        start: this.selectionStart,
        end: this.selectionEnd
      }, (0, _create.create)({
        html: this.value,
        range: null,
        multilineTag: this.multilineTag,
        multilineWrapperTags: this.multilineWrapperTags
      }));
      var start = Math.min(this.selectionStart, value.text.length);
      var end = Math.min(this.selectionEnd, value.text.length);
      return (0, _objectSpread2.default)({}, value, {
        start: start,
        end: end
      });
    }
    /**
     * Signals to the RichText owner that the block can be replaced with two
     * blocks as a result of splitting the block by pressing enter, or with
     * blocks as a result of splitting the block by pasting block content in the
     * instance.
     *
     * @param  {Object} record       The rich text value to split.
     * @param  {Array}  pastedBlocks The pasted blocks to insert, if any.
     */

  }, {
    key: "onSplit",
    value: function onSplit(record) {
      var pastedBlocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var _this$props2 = this.props,
          onReplace = _this$props2.__unstableOnReplace,
          onSplit = _this$props2.__unstableOnSplit,
          onSplitMiddle = _this$props2.__unstableOnSplitMiddle;

      if (!onReplace || !onSplit) {
        return;
      }

      var blocks = [];

      var _split = (0, _split3.split)(record),
          _split2 = (0, _slicedToArray2.default)(_split, 2),
          before = _split2[0],
          after = _split2[1];

      var hasPastedBlocks = pastedBlocks.length > 0; // Create a block with the content before the caret if there's no pasted
      // blocks, or if there are pasted blocks and the value is not empty.
      // We do not want a leading empty block on paste, but we do if split
      // with e.g. the enter key.

      if (!hasPastedBlocks || !(0, _isEmpty2.isEmpty)(before)) {
        blocks.push(onSplit(this.valueToFormat(before)));
      }

      if (hasPastedBlocks) {
        blocks.push.apply(blocks, (0, _toConsumableArray2.default)(pastedBlocks));
      } else if (onSplitMiddle) {
        blocks.push(onSplitMiddle());
      } // If there's pasted blocks, append a block with the content after the
      // caret. Otherwise, do append and empty block if there is no
      // `onSplitMiddle` prop, but if there is and the content is empty, the
      // middle block is enough to set focus in.


      if (hasPastedBlocks || !onSplitMiddle || !(0, _isEmpty2.isEmpty)(after)) {
        blocks.push(onSplit(this.valueToFormat(after)));
      } // If there are pasted blocks, set the selection to the last one.
      // Otherwise, set the selection to the second block.


      var indexToSelect = hasPastedBlocks ? blocks.length - 1 : 1; // The onSplit event can cause a content update event for this block.  Such event should
      // definitely be processed by our native components, since they have no knowledge of
      // how the split works.  Setting lastEventCount to undefined forces the native component to
      // always update when provided with new content.

      this.lastEventCount = undefined;
      onReplace(blocks, indexToSelect);
    }
  }, {
    key: "valueToFormat",
    value: function valueToFormat(value) {
      // remove the outer root tags
      return this.removeRootTagsProduceByAztec((0, _toHtmlString.toHTMLString)({
        value: value,
        multilineTag: this.multilineTag
      }));
    }
  }, {
    key: "getActiveFormatNames",
    value: function getActiveFormatNames(record) {
      var formatTypes = this.props.formatTypes;
      return formatTypes.map(function (_ref2) {
        var name = _ref2.name;
        return name;
      }).filter(function (name) {
        return (0, _getActiveFormat.getActiveFormat)(record, name) !== undefined;
      }).map(function (name) {
        return gutenbergFormatNamesToAztec[name];
      }).filter(Boolean);
    }
  }, {
    key: "onFormatChange",
    value: function onFormatChange(record) {
      var start = record.start,
          end = record.end,
          _record$activeFormats = record.activeFormats,
          activeFormats = _record$activeFormats === void 0 ? [] : _record$activeFormats;
      var changeHandlers = (0, _lodash.pickBy)(this.props, function (v, key) {
        return key.startsWith('format_on_change_functions_');
      });
      Object.values(changeHandlers).forEach(function (changeHandler) {
        changeHandler(record.formats, record.text);
      });
      this.value = this.valueToFormat(record);
      this.props.onChange(this.value);
      this.setState({
        activeFormats: activeFormats
      });
      this.props.onSelectionChange(start, end);
      this.selectionStart = start;
      this.selectionEnd = end;
      this.onCreateUndoLevel();
      this.lastAztecEventType = 'format change';
    }
  }, {
    key: "onCreateUndoLevel",
    value: function onCreateUndoLevel() {
      var onCreateUndoLevel = this.props.__unstableOnCreateUndoLevel; // If the content is the same, no level needs to be created.

      if (this.lastHistoryValue === this.value) {
        return;
      }

      onCreateUndoLevel();
      this.lastHistoryValue = this.value;
    }
    /*
     * Cleans up any root tags produced by aztec.
     * TODO: This should be removed on a later version when aztec doesn't return the top tag of the text being edited
     */

  }, {
    key: "removeRootTagsProduceByAztec",
    value: function removeRootTagsProduceByAztec(html) {
      var _this2 = this;

      var result = this.removeRootTag(this.props.tagName, html); // Temporary workaround for https://github.com/WordPress/gutenberg/pull/13763

      if (this.props.rootTagsToEliminate) {
        this.props.rootTagsToEliminate.forEach(function (element) {
          result = _this2.removeRootTag(element, result);
        });
      }

      if (this.props.tagsToEliminate) {
        this.props.tagsToEliminate.forEach(function (element) {
          result = _this2.removeTag(element, result);
        });
      }

      return result;
    }
  }, {
    key: "removeRootTag",
    value: function removeRootTag(tag, html) {
      var openingTagRegexp = RegExp('^<' + tag + '>', 'gim');
      var closingTagRegexp = RegExp('</' + tag + '>$', 'gim');
      return html.replace(openingTagRegexp, '').replace(closingTagRegexp, '');
    }
  }, {
    key: "removeTag",
    value: function removeTag(tag, html) {
      var openingTagRegexp = RegExp('<' + tag + '>', 'gim');
      var closingTagRegexp = RegExp('</' + tag + '>', 'gim');
      return html.replace(openingTagRegexp, '').replace(closingTagRegexp, '');
    }
    /*
     * Handles any case where the content of the AztecRN instance has changed
     */

  }, {
    key: "onChange",
    value: function onChange(event) {
      var contentWithoutRootTag = this.removeRootTagsProduceByAztec(unescapeSpaces(event.nativeEvent.text)); // On iOS, onChange can be triggered after selection changes, even though there are no content changes.

      if (contentWithoutRootTag === this.value) {
        return;
      }

      this.lastEventCount = event.nativeEvent.eventCount;
      this.comesFromAztec = true;
      this.firedAfterTextChanged = true; // the onChange event always fires after the fact

      this.onTextUpdate(event);
      this.lastAztecEventType = 'input';
    }
  }, {
    key: "onTextUpdate",
    value: function onTextUpdate(event) {
      var contentWithoutRootTag = this.removeRootTagsProduceByAztec(unescapeSpaces(event.nativeEvent.text));
      var refresh = this.value !== contentWithoutRootTag;
      this.value = contentWithoutRootTag; // we don't want to refresh if our goal is just to create a record

      if (refresh) {
        this.props.onChange(contentWithoutRootTag);
      }
    }
    /*
     * Handles any case where the content of the AztecRN instance has changed in size
     */

  }, {
    key: "onContentSizeChange",
    value: function onContentSizeChange(contentSize) {
      var contentHeight = contentSize.height;
      this.setState({
        height: contentHeight
      });
      this.lastAztecEventType = 'content size change';
    }
  }, {
    key: "onEnter",
    value: function onEnter(event) {
      if (this.props.onEnter) {
        this.props.onEnter();
        return;
      }

      var _this$props3 = this.props,
          onReplace = _this$props3.__unstableOnReplace,
          onSplit = _this$props3.__unstableOnSplit;
      this.lastEventCount = event.nativeEvent.eventCount;
      this.comesFromAztec = true;
      this.firedAfterTextChanged = event.nativeEvent.firedAfterTextChanged;
      var canSplit = onReplace && onSplit;
      var currentRecord = this.createRecord();

      if (this.multilineTag) {
        if (event.shiftKey) {
          this.needsSelectionUpdate = true;
          var insertedLineBreak = (0, _objectSpread2.default)({}, (0, _insert.insert)(currentRecord, '\n'));
          this.onFormatChange(insertedLineBreak);
        } else if (canSplit && (0, _isEmpty2.isEmptyLine)(currentRecord)) {
          this.onSplit(currentRecord);
        } else {
          this.needsSelectionUpdate = true;
          var insertedLineSeparator = (0, _objectSpread2.default)({}, (0, _insertLineSeparator.insertLineSeparator)(currentRecord));
          this.onFormatChange(insertedLineSeparator);
        }
      } else if (event.shiftKey || !onSplit) {
        this.needsSelectionUpdate = true;

        var _insertedLineBreak = (0, _objectSpread2.default)({}, (0, _insert.insert)(currentRecord, '\n'));

        this.onFormatChange(_insertedLineBreak);
      } else {
        this.onSplit(currentRecord);
      }

      this.lastAztecEventType = 'input';
    }
  }, {
    key: "onBackspace",
    value: function onBackspace(event) {
      var _this$props4 = this.props,
          onMerge = _this$props4.__unstableOnMerge,
          onRemove = _this$props4.__unstableOnRemove,
          onChange = _this$props4.onChange;

      if (!onMerge && !onRemove) {
        return;
      }

      var keyCode = _keycodes.BACKSPACE; // TODO : should we differentiate BACKSPACE and DELETE?

      var isReverse = keyCode === _keycodes.BACKSPACE;
      this.lastEventCount = event.nativeEvent.eventCount;
      this.comesFromAztec = true;
      this.firedAfterTextChanged = event.nativeEvent.firedAfterTextChanged;
      var value = this.createRecord();
      var start = value.start,
          end = value.end;
      var newValue; // Always handle full content deletion ourselves.

      if (start === 0 && end !== 0 && end >= value.text.length) {
        newValue = (0, _remove.remove)(value, start, end);
        onChange(newValue);
        return;
      }

      if (this.multilineTag) {
        newValue = (0, _removeLineSeparator.removeLineSeparator)(value, keyCode === _keycodes.BACKSPACE);

        if (newValue) {
          this.onFormatChange(newValue);
          return;
        }
      }

      var empty = this.isEmpty();

      if (onMerge) {
        onMerge(!isReverse);
      } // Only handle remove on Backspace. This serves dual-purpose of being
      // an intentional user interaction distinguishing between Backspace and
      // Delete to remove the empty field, but also to avoid merge & remove
      // causing destruction of two fields (merge, then removed merged).


      if (onRemove && empty && isReverse) {
        onRemove(!isReverse);
      }

      event.preventDefault();
      this.lastAztecEventType = 'input';
    }
    /**
     * Handles a paste event from the native Aztec Wrapper.
     *
     * @param {PasteEvent} event The paste event which wraps `nativeEvent`.
     */

  }, {
    key: "onPaste",
    value: function onPaste(event) {
      var _this$props5 = this.props,
          tagName = _this$props5.tagName,
          pasteHandler = _this$props5.__unstablePasteHandler,
          onReplace = _this$props5.__unstableOnReplace,
          onSplit = _this$props5.__unstableOnSplit,
          onChange = _this$props5.onChange;
      var _event$nativeEvent = event.nativeEvent,
          pastedText = _event$nativeEvent.pastedText,
          pastedHtml = _event$nativeEvent.pastedHtml,
          files = _event$nativeEvent.files;
      var currentRecord = this.createRecord();
      event.preventDefault(); // Only process file if no HTML is present.
      // Note: a pasted file may have the URL as plain text.

      if (files && files.length > 0) {
        var uploadId = Number.MAX_SAFE_INTEGER;
        var html = '';
        files.forEach(function (file) {
          html += "<img src=\"".concat(file, "\" class=\"wp-image-").concat(uploadId, "\">");
        });
        var content = pasteHandler({
          HTML: html,
          mode: 'BLOCKS',
          tagName: tagName
        });

        var _shouldReplace = onReplace && this.isEmpty();

        if (_shouldReplace) {
          onReplace(content);
        } else {
          this.onSplit(currentRecord, content);
        }

        return;
      } // There is a selection, check if a URL is pasted.


      if (!(0, _isCollapsed.isCollapsed)(currentRecord)) {
        var trimmedText = (pastedHtml || pastedText).replace(/<[^>]+>/g, '').trim(); // A URL was pasted, turn the selection into a link

        if ((0, _url.isURL)(trimmedText)) {
          var linkedRecord = (0, _applyFormat.applyFormat)(currentRecord, {
            type: 'a',
            attributes: {
              href: (0, _htmlEntities.decodeEntities)(trimmedText)
            }
          });
          this.value = this.valueToFormat(linkedRecord);
          onChange(this.value); // Allows us to ask for this information when we get a report.

          window.console.log('Created link:\n\n', trimmedText);
          return;
        }
      }

      var shouldReplace = this.props.onReplace && this.isEmpty();
      var mode = 'INLINE';

      if (shouldReplace) {
        mode = 'BLOCKS';
      } else if (onSplit) {
        mode = 'AUTO';
      }

      var pastedContent = saferPasteHandler(pasteHandler, {
        HTML: pastedHtml,
        plainText: pastedText,
        mode: mode,
        tagName: this.props.tagName,
        canUserUseUnfilteredHTML: this.props.canUserUseUnfilteredHTML
      });

      if (typeof pastedContent === 'string') {
        var recordToInsert = (0, _create.create)({
          html: pastedContent
        });
        var resultingRecord = (0, _insert.insert)(currentRecord, recordToInsert);
        var resultingContent = this.valueToFormat(resultingRecord);
        this.lastEventCount = undefined;
        this.value = resultingContent; // explicitly set selection after inline paste

        this.onSelectionChange(resultingRecord.start, resultingRecord.end);
        onChange(this.value);
      } else if (onSplit) {
        if (!pastedContent.length) {
          return;
        }

        if (shouldReplace) {
          onReplace(pastedContent);
        } else {
          this.onSplit(currentRecord, pastedContent);
        }
      }
    }
  }, {
    key: "onFocus",
    value: function onFocus() {
      this.isTouched = true;
      var _this$props6 = this.props,
          unstableOnFocus = _this$props6.unstableOnFocus,
          onSelectionChange = _this$props6.onSelectionChange;

      if (unstableOnFocus) {
        unstableOnFocus();
      } // We know for certain that on focus, the old selection is invalid. It
      // will be recalculated on `selectionchange`.


      var index = undefined;
      onSelectionChange(index, index);
      this.lastAztecEventType = 'focus';
    }
  }, {
    key: "onBlur",
    value: function onBlur(event) {
      this.isTouched = false;

      if (this.props.onBlur) {
        this.props.onBlur(event);
      }

      this.lastAztecEventType = 'blur';
    }
  }, {
    key: "onSelectionChange",
    value: function onSelectionChange(start, end) {
      var hasChanged = this.selectionStart !== start || this.selectionEnd !== end;
      this.selectionStart = start;
      this.selectionEnd = end; // This is a manual selection change event if onChange was not triggered just before
      // and we did not just trigger a text update
      // `onChange` could be the last event and could have been triggered a long time ago so
      // this approach is not perfectly reliable

      var isManual = this.lastAztecEventType !== 'input' && this.props.value === this.value;

      if (hasChanged && isManual) {
        var value = this.createRecord();
        var activeFormats = (0, _getActiveFormats.getActiveFormats)(value);
        this.setState({
          activeFormats: activeFormats
        });
      }

      this.props.onSelectionChange(start, end);
    }
  }, {
    key: "onSelectionChangeFromAztec",
    value: function onSelectionChangeFromAztec(start, end, text, event) {
      // `end` can be less than `start` on iOS
      // Let's fix that here so `rich-text/slice` can work properly
      var realStart = Math.min(start, end);
      var realEnd = Math.max(start, end); // check and dicsard stray event, where the text and selection is equal to the ones already cached

      var contentWithoutRootTag = this.removeRootTagsProduceByAztec(unescapeSpaces(event.nativeEvent.text));

      if (contentWithoutRootTag === this.value && realStart === this.selectionStart && realEnd === this.selectionEnd) {
        return;
      }

      this.comesFromAztec = true;
      this.firedAfterTextChanged = true; // Selection change event always fires after the fact
      // update text before updating selection
      // Make sure there are changes made to the content before upgrading it upward

      this.onTextUpdate(event);
      this.onSelectionChange(realStart, realEnd); // Update lastEventCount to prevent Aztec from re-rendering the content it just sent

      this.lastEventCount = event.nativeEvent.eventCount;
      this.lastAztecEventType = 'selection change';
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return (0, _isEmpty2.isEmpty)(this.formatToValue(this.props.value));
    }
  }, {
    key: "formatToValue",
    value: function formatToValue(value) {
      // Handle deprecated `children` and `node` sources.
      if (Array.isArray(value)) {
        return (0, _create.create)({
          html: _blocks.childrenBlock.toHTML(value),
          multilineTag: this.multilineTag,
          multilineWrapperTags: this.multilineWrapperTags
        });
      }

      if (this.props.format === 'string') {
        return (0, _create.create)({
          html: value,
          multilineTag: this.multilineTag,
          multilineWrapperTags: this.multilineWrapperTags
        });
      } // Guard for blocks passing `null` in onSplit callbacks. May be removed
      // if onSplit is revised to not pass a `null` value.


      if (value === null) {
        return (0, _create.create)();
      }

      return value;
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      if (nextProps.tagName !== this.props.tagName) {
        this.lastEventCount = undefined;
        this.value = undefined;
        return true;
      } // TODO: Please re-introduce the check to avoid updating the content right after an `onChange` call.
      // It was removed in https://github.com/WordPress/gutenberg/pull/12417 to fix undo/redo problem.
      // If the component is changed React side (undo/redo/merging/splitting/custom text actions)
      // we need to make sure the native is updated as well.
      // Also, don't trust the "this.lastContent" as on Android, incomplete text events arrive
      //  with only some of the text, while the virtual keyboard's suggestion system does its magic.
      // ** compare with this.lastContent for optimizing performance by not forcing Aztec with text it already has
      // , but compare with props.value to not lose "half word" text because of Android virtual keyb autosuggestion behavior


      if (typeof nextProps.value !== 'undefined' && typeof this.props.value !== 'undefined' && (!this.comesFromAztec || !this.firedAfterTextChanged) && nextProps.value !== this.props.value) {
        // Gutenberg seems to try to mirror the caret state even on events that only change the content so,
        //  let's force caret update if state has selection set.
        if (typeof nextProps.selectionStart !== 'undefined' && typeof nextProps.selectionEnd !== 'undefined') {
          this.needsSelectionUpdate = true;
        }

        this.lastEventCount = undefined; // force a refresh on the native side
      }

      if (!this.comesFromAztec) {
        if (typeof nextProps.selectionStart !== 'undefined' && typeof nextProps.selectionEnd !== 'undefined' && nextProps.selectionStart !== this.props.selectionStart && nextProps.selectionStart !== this.selectionStart && nextProps.__unstableIsSelected) {
          this.needsSelectionUpdate = true;
          this.lastEventCount = undefined; // force a refresh on the native side
        }
      }

      return true;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      // Request focus if wrapping block is selected and parent hasn't inhibited the focus request. This method of focusing
      //  is trying to implement the web-side counterpart of BlockList's `focusTabbable` where the BlockList is focusing an
      //  inputbox by searching the DOM. We don't have the DOM in RN so, using the combination of blockIsSelected and __unstableMobileNoFocusOnMount
      //  to determine if we should focus the RichText.
      if (this.props.blockIsSelected && !this.props.__unstableMobileNoFocusOnMount) {
        this._editor.focus();

        this.onSelectionChange(this.props.selectionStart || 0, this.props.selectionEnd || 0);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._editor.isFocused() && this.props.shouldBlurOnUnmount) {
        this._editor.blur();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.value !== this.value) {
        this.value = this.props.value;
        this.lastEventCount = undefined;
      }

      var isSelected = this.props.__unstableIsSelected;
      var prevIsSelected = prevProps.__unstableIsSelected;

      if (isSelected && !prevIsSelected) {
        this._editor.focus(); // Update selection props explicitly when component is selected as Aztec won't call onSelectionChange
        // if its internal value hasn't change. When created, default value is 0, 0


        this.onSelectionChange(this.props.selectionStart || 0, this.props.selectionEnd || 0);
      } else if (!isSelected && prevIsSelected) {
        this._editor.blur();
      }
    }
  }, {
    key: "willTrimSpaces",
    value: function willTrimSpaces(html) {
      // regex for detecting spaces around block element html tags
      var blockHtmlElements = '(div|br|blockquote|ul|ol|li|p|pre|h1|h2|h3|h4|h5|h6|iframe|hr)';
      var leadingOrTrailingSpaces = new RegExp("(\\s+)</?".concat(blockHtmlElements, ">|</?").concat(blockHtmlElements, ">(\\s+)"), 'g');
      var matches = html.match(leadingOrTrailingSpaces);

      if (matches && matches.length > 0) {
        return true;
      }

      return false;
    }
  }, {
    key: "getHtmlToRender",
    value: function getHtmlToRender(record, tagName) {
      // Save back to HTML from React tree
      var value = this.valueToFormat(record);

      if (value === undefined || value === '') {
        this.lastEventCount = undefined; // force a refresh on the native side

        return '';
      } else if (tagName) {
        return "<".concat(tagName, ">").concat(value, "</").concat(tagName, ">");
      }

      return value;
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props7 = this.props,
          tagName = _this$props7.tagName,
          style = _this$props7.style,
          isSelected = _this$props7.__unstableIsSelected,
          children = _this$props7.children;
      var record = this.getRecord();
      var html = this.getHtmlToRender(record, tagName);
      var minHeight = _style.default['rich-text'].minHeight;

      if (style && style.minHeight) {
        minHeight = style.minHeight;
      }

      var defaultPlaceholderTextColor = _style.default['rich-text-placeholder'].color;
      var _styles$richText = _style.default['rich-text'],
          defaultColor = _styles$richText.color,
          defaultTextDecorationColor = _styles$richText.textDecorationColor,
          defaultFontFamily = _styles$richText.fontFamily;
      var selection = null;

      if (this.needsSelectionUpdate) {
        this.needsSelectionUpdate = false;
        selection = {
          start: this.props.selectionStart,
          end: this.props.selectionEnd
        }; // On AztecAndroid, setting the caret to an out-of-bounds position will crash the editor so, let's check for some cases.

        if (!this.isIOS) {
          // Aztec performs some html text cleanup while parsing it so, its internal representation gets out-of-sync with the
          // representation of the format-lib on the RN side. We need to avoid trying to set the caret position because it may
          // be outside the text bounds and crash Aztec, at least on Android.
          if (this.willTrimSpaces(html)) {
            // the html will get trimmed by the cleaning up functions in Aztec and caret position will get out-of-sync.
            // So, skip forcing it, let Aztec just do its best and just log the fact.
            console.warn('RichText value will be trimmed for spaces! Avoiding setting the caret position manually.');
            selection = null;
          } else if (this.props.selectionStart > record.text.length || this.props.selectionEnd > record.text.length) {
            console.warn('Oops, selection will land outside the text, skipping setting it...');
            selection = null;
          }
        }
      }

      if (this.comesFromAztec) {
        this.comesFromAztec = false;
        this.firedAfterTextChanged = false;
      }

      return (0, _element.createElement)(_reactNative.View, null, children && children({
        isSelected: isSelected,
        value: record,
        onChange: this.onFormatChange
      }), (0, _element.createElement)(_reactNativeAztec.default, {
        ref: function ref(_ref3) {
          _this3._editor = _ref3;

          if (_this3.props.setRef) {
            _this3.props.setRef(_ref3);
          }
        },
        style: (0, _objectSpread2.default)({}, style, {
          minHeight: Math.max(minHeight, this.state.height)
        }),
        text: {
          text: html,
          eventCount: this.lastEventCount,
          selection: selection
        },
        placeholder: this.props.placeholder,
        placeholderTextColor: this.props.placeholderTextColor || defaultPlaceholderTextColor,
        deleteEnter: this.props.deleteEnter,
        onChange: this.onChange,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onEnter: this.onEnter,
        onBackspace: this.onBackspace,
        onPaste: this.onPaste,
        activeFormats: this.getActiveFormatNames(record),
        onContentSizeChange: this.onContentSizeChange,
        onCaretVerticalPositionChange: this.props.onCaretVerticalPositionChange,
        onSelectionChange: this.onSelectionChangeFromAztec,
        blockType: {
          tag: tagName
        },
        color: defaultColor,
        linkTextColor: defaultTextDecorationColor,
        maxImagesWidth: 200,
        fontFamily: this.props.fontFamily || defaultFontFamily,
        fontSize: this.props.fontSize || style && style.fontSize,
        fontWeight: this.props.fontWeight,
        fontStyle: this.props.fontStyle,
        disableEditingMenu: this.props.disableEditingMenu,
        isMultiline: this.isMultiline,
        textAlign: this.props.textAlign
      }), isSelected && (0, _element.createElement)(_formatEdit.default, {
        value: record,
        onChange: this.onFormatChange
      }));
    }
  }]);
  return RichText;
}(_element.Component);

exports.RichText = RichText;
RichText.defaultProps = {
  format: 'string',
  value: '',
  tagName: 'div'
};

var _default = (0, _compose.compose)([(0, _data.withSelect)(function (select) {
  return {
    formatTypes: select('core/rich-text').getFormatTypes()
  };
})])(RichText);

exports.default = _default;
//# sourceMappingURL=index.native.js.map