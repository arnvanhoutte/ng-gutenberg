{"version":3,"sources":["@wordpress/block-editor/src/components/ignore-nested-events/index.js"],"names":["IgnoreNestedEvents","arguments","proxyEvent","bind","eventMap","event","isHandled","nativeEvent","_blockHandled","propKey","type","props","childHandledEvents","forwardedRef","tagName","eventHandlers","Object","keys","result","key","match","isHandledProp","proxiedPropName","toLowerCase","ref","Component","forwardedIgnoreNestedEvents","displayName"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;AAKA;;AARA;;;;AAKA;;;;AAKA;;;;;;;;;;;;;;IAcaA,kB;;;;;AACZ,gCAAc;AAAA;;AAAA;AACb,yHAAUC,SAAV;AAEA,UAAKC,UAAL,GAAkB,MAAKA,UAAL,CAAgBC,IAAhB,6CAAlB,CAHa,CAKb;AACA;AACA;;AACA,UAAKC,QAAL,GAAgB,EAAhB;AARa;AASb;AAED;;;;;;;;;;+BAMYC,K,EAAQ;AACnB,UAAMC,SAAS,GAAG,CAAC,CAAED,KAAK,CAACE,WAAN,CAAkBC,aAAvC,CADmB,CAGnB;AACA;AACA;AACA;;AACAH,MAAAA,KAAK,CAACE,WAAN,CAAkBC,aAAlB,GAAkC,IAAlC,CAPmB,CASnB;;AACA,UAAIC,OAAO,GAAG,KAAKL,QAAL,CAAeC,KAAK,CAACK,IAArB,CAAd,CAVmB,CAYnB;AACA;;AACA,UAAKJ,SAAL,EAAiB;AAChBG,QAAAA,OAAO,IAAI,SAAX;AACA;;AAED,UAAK,KAAKE,KAAL,CAAYF,OAAZ,CAAL,EAA6B;AAC5B,aAAKE,KAAL,CAAYF,OAAZ,EAAuBJ,KAAvB;AACA;AACD;;;6BAEQ;AAAA;;AAAA,wBACqE,KAAKM,KAD1E;AAAA,8CACAC,kBADA;AAAA,UACAA,kBADA,sCACqB,EADrB;AAAA,UACyBC,YADzB,eACyBA,YADzB;AAAA,4CACuCC,OADvC;AAAA,UACuCA,OADvC,oCACiD,KADjD;AAAA,UAC2DH,KAD3D;AAGR,UAAMI,aAAa,GAAG,+DAClBH,kBADkB,oCAElBI,MAAM,CAACC,IAAP,CAAaN,KAAb,CAFkB,IAGnB,UAAEO,MAAF,EAAUC,GAAV,EAAmB;AACrB;AACA,YAAMC,KAAK,GAAGD,GAAG,CAACC,KAAJ,CAAW,iCAAX,CAAd;;AACA,YAAKA,KAAL,EAAa;AACZ,cAAMC,aAAa,GAAG,CAAC,CAAED,KAAK,CAAE,CAAF,CAA9B;;AACA,cAAKC,aAAL,EAAqB;AACpB;AACA;AACA,mBAAOV,KAAK,CAAEQ,GAAF,CAAZ;AACA,WANW,CAQZ;AACA;;;AACA,cAAMG,eAAe,GAAG,OAAOF,KAAK,CAAE,CAAF,CAApC;AACAF,UAAAA,MAAM,CAAEI,eAAF,CAAN,GAA4B,MAAI,CAACpB,UAAjC,CAXY,CAaZ;AACA;AACA;;AACA,UAAA,MAAI,CAACE,QAAL,CAAegB,KAAK,CAAE,CAAF,CAAL,CAAWG,WAAX,EAAf,IAA4CD,eAA5C;AACA;;AAED,eAAOJ,MAAP;AACA,OA1BqB,EA0BnB,EA1BmB,CAAtB;AA4BA,aAAO,4BAAeJ,OAAf;AAA0BU,QAAAA,GAAG,EAAEX;AAA/B,SAAgDF,KAAhD,EAA0DI,aAA1D,EAAP;AACA;;;EAzEsCU,kB;;;;AA4ExC,IAAMC,2BAA2B,GAAG,SAA9BA,2BAA8B,CAAEf,KAAF,EAASa,GAAT,EAAkB;AACrD,SAAO,4BAAC,kBAAD,6BAAyBb,KAAzB;AAAiC,IAAA,YAAY,EAAGa;AAAhD,KAAP;AACA,CAFD;;AAGAE,2BAA2B,CAACC,WAA5B,GAA0C,oBAA1C;;eAEe,yBAAYD,2BAAZ,C","sourcesContent":["/**\n * External dependencies\n */\nimport { reduce } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { Component, forwardRef, createElement } from '@wordpress/element';\n\n/**\n * Component which renders a div with passed props applied except the optional\n * `childHandledEvents` prop. Event prop handlers are replaced with a proxying\n * event handler to capture and prevent events from being handled by ancestor\n * `IgnoreNestedEvents` elements by testing the presence of a private property\n * assigned on the event object.\n *\n * Optionally accepts an `childHandledEvents` prop array, which can be used in\n * instances where an inner `IgnoreNestedEvents` element exists and the outer\n * element should stop propagation but not invoke a callback handler, since it\n * would be assumed these are invoked by the child element.\n *\n * @type {Component}\n */\nexport class IgnoreNestedEvents extends Component {\n\tconstructor() {\n\t\tsuper( ...arguments );\n\n\t\tthis.proxyEvent = this.proxyEvent.bind( this );\n\n\t\t// The event map is responsible for tracking an event type to a React\n\t\t// component prop name, since it is easy to determine event type from\n\t\t// a React prop name, but not the other way around.\n\t\tthis.eventMap = {};\n\t}\n\n\t/**\n\t * General event handler which only calls to its original props callback if\n\t * it has not already been handled by a descendant IgnoreNestedEvents.\n\t *\n\t * @param {Event} event Event object.\n\t */\n\tproxyEvent( event ) {\n\t\tconst isHandled = !! event.nativeEvent._blockHandled;\n\n\t\t// Assign into the native event, since React will reuse their synthetic\n\t\t// event objects and this property assignment could otherwise leak.\n\t\t//\n\t\t// See: https://reactjs.org/docs/events.html#event-pooling\n\t\tevent.nativeEvent._blockHandled = true;\n\n\t\t// Invoke original prop handler\n\t\tlet propKey = this.eventMap[ event.type ];\n\n\t\t// If already handled (i.e. assume nested block), only invoke a\n\t\t// corresponding \"Handled\"-suffixed prop callback.\n\t\tif ( isHandled ) {\n\t\t\tpropKey += 'Handled';\n\t\t}\n\n\t\tif ( this.props[ propKey ] ) {\n\t\t\tthis.props[ propKey ]( event );\n\t\t}\n\t}\n\n\trender() {\n\t\tconst { childHandledEvents = [], forwardedRef, tagName = 'div', ...props } = this.props;\n\n\t\tconst eventHandlers = reduce( [\n\t\t\t...childHandledEvents,\n\t\t\t...Object.keys( props ),\n\t\t], ( result, key ) => {\n\t\t\t// Try to match prop key as event handler\n\t\t\tconst match = key.match( /^on([A-Z][a-zA-Z]+?)(Handled)?$/ );\n\t\t\tif ( match ) {\n\t\t\t\tconst isHandledProp = !! match[ 2 ];\n\t\t\t\tif ( isHandledProp ) {\n\t\t\t\t\t// Avoid assigning through the invalid prop key. This\n\t\t\t\t\t// assumes mutation of shallow clone by above spread.\n\t\t\t\t\tdelete props[ key ];\n\t\t\t\t}\n\n\t\t\t\t// Re-map the prop to the local proxy handler to check whether\n\t\t\t\t// the event has already been handled.\n\t\t\t\tconst proxiedPropName = 'on' + match[ 1 ];\n\t\t\t\tresult[ proxiedPropName ] = this.proxyEvent;\n\n\t\t\t\t// Assign event -> propName into an instance variable, so as to\n\t\t\t\t// avoid re-renders which could be incurred either by setState\n\t\t\t\t// or in mapping values to a newly created function.\n\t\t\t\tthis.eventMap[ match[ 1 ].toLowerCase() ] = proxiedPropName;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}, {} );\n\n\t\treturn createElement( tagName, { ref: forwardedRef, ...props, ...eventHandlers } );\n\t}\n}\n\nconst forwardedIgnoreNestedEvents = ( props, ref ) => {\n\treturn <IgnoreNestedEvents { ...props } forwardedRef={ ref } />;\n};\nforwardedIgnoreNestedEvents.displayName = 'IgnoreNestedEvents';\n\nexport default forwardRef( forwardedIgnoreNestedEvents );\n"]}