(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/platform-browser'), require('react'), require('react-dom'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@angular-react/core', ['exports', '@angular/core', '@angular/platform-browser', 'react', 'react-dom', 'rxjs/operators'], factory) :
    (global = global || self, factory((global['angular-react'] = global['angular-react'] || {}, global['angular-react'].core = {}), global.ng.core, global.ng.platformBrowser, global.React, global.ReactDOM, global.rxjs.operators));
}(this, function (exports, core, platformBrowser, react, reactDom, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var classnames = createCommonjsModule(function (module) {
    /*!
      Copyright (c) 2017 Jed Watson.
      Licensed under the MIT License (MIT), see
      http://jedwatson.github.io/classnames
    */
    /* global define */

    (function () {

    	var hasOwn = {}.hasOwnProperty;

    	function classNames () {
    		var classes = [];

    		for (var i = 0; i < arguments.length; i++) {
    			var arg = arguments[i];
    			if (!arg) continue;

    			var argType = typeof arg;

    			if (argType === 'string' || argType === 'number') {
    				classes.push(arg);
    			} else if (Array.isArray(arg) && arg.length) {
    				var inner = classNames.apply(null, arg);
    				if (inner) {
    					classes.push(inner);
    				}
    			} else if (argType === 'object') {
    				for (var key in arg) {
    					if (hasOwn.call(arg, key) && arg[key]) {
    						classes.push(key);
    					}
    				}
    			}
    		}

    		return classes.join(' ');
    	}

    	if ( module.exports) {
    		classNames.default = classNames;
    		module.exports = classNames;
    	} else {
    		window.classNames = classNames;
    	}
    }());
    });

    var lib = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var camelCase = function camelCase(str) {
      return str.replace(/\-(\w|$)/g, function (m, p1) {
        return p1.toUpperCase();
      });
    };

    var cssToStyle = function cssToStyle(cssText) {
      var declarations = [];
      var capturing;
      var i = cssText.length;
      var last = i; // Split into declarations by semi-colon (outside quotes or parentheses)

      while (i-- > -1) {
        // Capture unescaped quotes
        if ((cssText[i] === '"' || cssText[i] === "'") && cssText[i - 1] !== '\\') {
          if (!capturing) {
            capturing = cssText[i];
          } else if (cssText[i] === capturing) {
            capturing = false;
          }
        } // Start capturing parentheses


        if (!capturing && cssText[i] === ')') {
          capturing = cssText[i];
        } // Stop capturing parentheses


        if (cssText[i] === '(' && capturing === ')') {
          capturing = false;
        } // Split at semi-colon


        if (i < 0 || !capturing && cssText[i] === ';') {
          declarations.unshift(cssText.slice(i + 1, last));
          last = i;
        }
      }

      return declarations.reduce(function (styles, rule) {
        var i = rule.indexOf(':');
        var value = rule.substr(i + 1).trim();
        var prop = rule.substr(0, i).toLowerCase().trim();

        if (prop && value) {
          if (prop === 'float') {
            prop = 'cssFloat';
          } else if (prop.substr(0, 4) === '-ms-') {
            prop = camelCase(prop.substr(1));
          } else if (prop.substr(0, 2) !== '--') {
            prop = camelCase(prop);
          }

          styles[prop] = value;
        }

        return styles;
      }, {});
    };

    var _default = cssToStyle;
    exports.default = _default;
    });

    var toStyle = unwrapExports(lib);

    var validTypes = { object: true, symbol: true };

    var isImplemented = function () {
    	var symbol;
    	if (typeof Symbol !== 'function') return false;
    	symbol = Symbol('test symbol');
    	try { String(symbol); } catch (e) { return false; }

    	// Return 'true' also for polyfills
    	if (!validTypes[typeof Symbol.iterator]) return false;
    	if (!validTypes[typeof Symbol.toPrimitive]) return false;
    	if (!validTypes[typeof Symbol.toStringTag]) return false;

    	return true;
    };

    /* eslint strict: "off" */

    var global = (function () {
    	return this;
    }());

    var isImplemented$1 = function () {
    	var assign = Object.assign, obj;
    	if (typeof assign !== "function") return false;
    	obj = { foo: "raz" };
    	assign(obj, { bar: "dwa" }, { trzy: "trzy" });
    	return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
    };

    var isImplemented$2 = function () {
    	try {
    		Object.keys("primitive");
    		return true;
    	} catch (e) {
    		return false;
    	}
    };

    // eslint-disable-next-line no-empty-function
    var noop = function () {};

    var _undefined = noop(); // Support ES3 engines

    var isValue = function (val) {
     return (val !== _undefined) && (val !== null);
    };

    var keys = Object.keys;

    var shim = function (object) { return keys(isValue(object) ? Object(object) : object); };

    var keys$1 = isImplemented$2() ? Object.keys : shim;

    var validValue = function (value) {
    	if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
    	return value;
    };

    var max   = Math.max;

    var shim$1 = function (dest, src /*, …srcn*/) {
    	var error, i, length = max(arguments.length, 2), assign;
    	dest = Object(validValue(dest));
    	assign = function (key) {
    		try {
    			dest[key] = src[key];
    		} catch (e) {
    			if (!error) error = e;
    		}
    	};
    	for (i = 1; i < length; ++i) {
    		src = arguments[i];
    		keys$1(src).forEach(assign);
    	}
    	if (error !== undefined) throw error;
    	return dest;
    };

    var assign = isImplemented$1()
    	? Object.assign
    	: shim$1;

    var forEach = Array.prototype.forEach, create = Object.create;

    var process = function (src, obj) {
    	var key;
    	for (key in src) obj[key] = src[key];
    };

    // eslint-disable-next-line no-unused-vars
    var normalizeOptions = function (opts1 /*, …options*/) {
    	var result = create(null);
    	forEach.call(arguments, function (options) {
    		if (!isValue(options)) return;
    		process(Object(options), result);
    	});
    	return result;
    };

    // Deprecated

    var isCallable = function (obj) {
     return typeof obj === "function";
    };

    var str = "razdwatrzy";

    var isImplemented$3 = function () {
    	if (typeof str.contains !== "function") return false;
    	return (str.contains("dwa") === true) && (str.contains("foo") === false);
    };

    var indexOf = String.prototype.indexOf;

    var shim$2 = function (searchString/*, position*/) {
    	return indexOf.call(this, searchString, arguments[1]) > -1;
    };

    var contains = isImplemented$3()
    	? String.prototype.contains
    	: shim$2;

    var d_1 = createCommonjsModule(function (module) {

    var d;

    d = module.exports = function (dscr, value/*, options*/) {
    	var c, e, w, options, desc;
    	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
    		options = value;
    		value = dscr;
    		dscr = null;
    	} else {
    		options = arguments[2];
    	}
    	if (dscr == null) {
    		c = w = true;
    		e = false;
    	} else {
    		c = contains.call(dscr, 'c');
    		e = contains.call(dscr, 'e');
    		w = contains.call(dscr, 'w');
    	}

    	desc = { value: value, configurable: c, enumerable: e, writable: w };
    	return !options ? desc : assign(normalizeOptions(options), desc);
    };

    d.gs = function (dscr, get, set/*, options*/) {
    	var c, e, options, desc;
    	if (typeof dscr !== 'string') {
    		options = set;
    		set = get;
    		get = dscr;
    		dscr = null;
    	} else {
    		options = arguments[3];
    	}
    	if (get == null) {
    		get = undefined;
    	} else if (!isCallable(get)) {
    		options = get;
    		get = set = undefined;
    	} else if (set == null) {
    		set = undefined;
    	} else if (!isCallable(set)) {
    		options = set;
    		set = undefined;
    	}
    	if (dscr == null) {
    		c = true;
    		e = false;
    	} else {
    		c = contains.call(dscr, 'c');
    		e = contains.call(dscr, 'e');
    	}

    	desc = { get: get, set: set, configurable: c, enumerable: e };
    	return !options ? desc : assign(normalizeOptions(options), desc);
    };
    });

    var isSymbol = function (x) {
    	if (!x) return false;
    	if (typeof x === 'symbol') return true;
    	if (!x.constructor) return false;
    	if (x.constructor.name !== 'Symbol') return false;
    	return (x[x.constructor.toStringTag] === 'Symbol');
    };

    var validateSymbol = function (value) {
    	if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
    	return value;
    };

    var create$1 = Object.create, defineProperties = Object.defineProperties
      , defineProperty = Object.defineProperty, objPrototype = Object.prototype
      , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$1(null)
      , isNativeSafe;

    if (typeof Symbol === 'function') {
    	NativeSymbol = Symbol;
    	try {
    		String(NativeSymbol());
    		isNativeSafe = true;
    	} catch (ignore) {}
    }

    var generateName = (function () {
    	var created = create$1(null);
    	return function (desc) {
    		var postfix = 0, name, ie11BugWorkaround;
    		while (created[desc + (postfix || '')]) ++postfix;
    		desc += (postfix || '');
    		created[desc] = true;
    		name = '@@' + desc;
    		defineProperty(objPrototype, name, d_1.gs(null, function (value) {
    			// For IE11 issue see:
    			// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
    			//    ie11-broken-getters-on-dom-objects
    			// https://github.com/medikoo/es6-symbol/issues/12
    			if (ie11BugWorkaround) return;
    			ie11BugWorkaround = true;
    			defineProperty(this, name, d_1(value));
    			ie11BugWorkaround = false;
    		}));
    		return name;
    	};
    }());

    // Internal constructor (not one exposed) for creating Symbol instances.
    // This one is used to ensure that `someSymbol instanceof Symbol` always return false
    HiddenSymbol = function Symbol(description) {
    	if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
    	return SymbolPolyfill(description);
    };

    // Exposed `Symbol` constructor
    // (returns instances of HiddenSymbol)
    var polyfill = SymbolPolyfill = function Symbol(description) {
    	var symbol;
    	if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
    	if (isNativeSafe) return NativeSymbol(description);
    	symbol = create$1(HiddenSymbol.prototype);
    	description = (description === undefined ? '' : String(description));
    	return defineProperties(symbol, {
    		__description__: d_1('', description),
    		__name__: d_1('', generateName(description))
    	});
    };
    defineProperties(SymbolPolyfill, {
    	for: d_1(function (key) {
    		if (globalSymbols[key]) return globalSymbols[key];
    		return (globalSymbols[key] = SymbolPolyfill(String(key)));
    	}),
    	keyFor: d_1(function (s) {
    		var key;
    		validateSymbol(s);
    		for (key in globalSymbols) if (globalSymbols[key] === s) return key;
    	}),

    	// To ensure proper interoperability with other native functions (e.g. Array.from)
    	// fallback to eventual native implementation of given symbol
    	hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
    	isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
    		SymbolPolyfill('isConcatSpreadable')),
    	iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
    	match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
    	replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
    	search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
    	species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
    	split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
    	toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
    	toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
    	unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
    });

    // Internal tweaks for real symbol producer
    defineProperties(HiddenSymbol.prototype, {
    	constructor: d_1(SymbolPolyfill),
    	toString: d_1('', function () { return this.__name__; })
    });

    // Proper implementation of methods exposed on Symbol.prototype
    // They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
    defineProperties(SymbolPolyfill.prototype, {
    	toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
    	valueOf: d_1(function () { return validateSymbol(this); })
    });
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
    	var symbol = validateSymbol(this);
    	if (typeof symbol === 'symbol') return symbol;
    	return symbol.toString();
    }));
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

    // Proper implementaton of toPrimitive and toStringTag for returned symbol instances
    defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
    	d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

    // Note: It's important to define `toPrimitive` as last one, as some implementations
    // implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
    // And that may invoke error in definition flow:
    // See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
    defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
    	d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

    if (!isImplemented()) {
    	Object.defineProperty(global, 'Symbol',
    		{ value: polyfill, configurable: true, enumerable: false,
    			writable: true });
    }

    var lib$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    exports.default = styleNames;



    /**
     * Convert Object to CSS style String.
     *
     *   Example:
     *      {
     *          height: "20px",
     *          width: {
     *              "20px": false,
     *              "30px": true,
     *              "40px": true
     *          }
     *      }
     *      returns: ' "height:20px;width:30px;" '
     *
     * @param styles
     * @returns {string}
     */
    function styleNames(styles) {
        if (!styles || (typeof styles === 'undefined' ? 'undefined' : _typeof(styles)) !== 'object') {
            return '""';
        }

        var styleNames = '';

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Object.keys(styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var key = _step.value;

                if (typeof styles[key] === 'string') {
                    styleNames += key + ':' + styles[key] + ';';
                    continue;
                }

                if (_typeof(styles[key]) !== 'object' || styles[key].length === 0) {
                    continue;
                }

                var conditions = styles[key];

                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Object.keys(conditions)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var value = _step2.value;

                        if (typeof conditions[value] !== 'function' && conditions[value] || typeof conditions[value] === 'function' && conditions[value]()) {
                            styleNames += key + ':' + value + ';';
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return '' + styleNames;
    }
    module.exports = exports['default'];
    });

    var stylenames = unwrapExports(lib$1);

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    var passPropsSymbol = Symbol('passProps');
    function passPropImpl(target, propertyKey, targetKey) {
        if (!target[passPropsSymbol]) {
            target[passPropsSymbol] = [];
        }
        target[passPropsSymbol].push({
            sourceKey: propertyKey,
            targetKey: targetKey,
        });
    }
    var passPropRename = function (propName) { return function (target, propertyKey) {
        return passPropImpl(target, propertyKey, propName);
    }; };
    var passPropDirect = function (target, propertyKey) { return passPropImpl(target, propertyKey, propertyKey); };
    function passProp() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 0) {
            return passPropDirect;
        }
        if (args.length === 1) {
            return passPropRename(args[0]);
        }
        throw new Error('[passProp] Only 0 or 1 arguments accepted.');
    }
    function getPassProps(obj) {
        return obj[passPropsSymbol];
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Remove all undefined properties from obj.
     *
     * Does **not** modify the original object.
     * @returns A clone of `obj`, with all `undefined` properties removed
     */
    var removeUndefinedProperties = function (obj) {
        return Object.entries(obj).reduce(function (acc, _a) {
            var _b;
            var _c = __read(_a, 2), key = _c[0], value = _c[1];
            if (value === undefined)
                return acc;
            return Object.assign(acc, (_b = {}, _b[key] = value, _b));
        }, {});
    };

    /**
     * Checks if a node is in the DOM.
     *
     * @param node The node to check
     * @returns whether the node is in the DOM
     */
    var isNodeInDOM = function (node) { return node.isConnected || document.body.contains(node); };

    // Copyright (c) Microsoft Corporation. All rights reserved.
    var CHILDREN_TO_APPEND_PROP = 'children-to-append';
    /**
     * Creates a new `ReactContent` element.
     * @param children The children to append to the `ReactContent` element.
     * @param additionalProps _Optional_. @see `ReactContentProps`.
     */
    function createReactContentElement(children, additionalProps) {
        var _a;
        return react.createElement(ReactContent, __assign({}, additionalProps, (_a = {}, _a[CHILDREN_TO_APPEND_PROP] = children, _a)));
    }
    /**
     * Render any `HTMLElement`s as a child of React components.
     * Supports two rendering modes:
     *  1. `legacy` - append `<react-content>` as the root, and nest the `children-to-append` underneath it.
     *  2. `new` (**default**) - append the `children-to-append` to the parent of this component, and hide the `<react-content>` element.
     *     (similar to how `router-outlet` behaves in Angular).
     */
    var ReactContent = /** @class */ (function (_super) {
        __extends(ReactContent, _super);
        function ReactContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ReactContent.prototype.componentDidMount = function () {
            var element = reactDom.findDOMNode(this);
            if (this.props[CHILDREN_TO_APPEND_PROP]) {
                var hostElement_1 = this.props.legacyRenderMode ? element : element.parentElement;
                // Only add children not already in the DOM
                this.props[CHILDREN_TO_APPEND_PROP].filter(function (child) { return !isNodeInDOM(child); }).forEach(function (child) {
                    return hostElement_1.appendChild(child);
                });
            }
        };
        ReactContent.prototype.render = function () {
            // TODO: See if we can just render React.Fragment and the children within it, having no extra DOM nodes.
            return react.createElement('react-content', !this.props.legacyRenderMode && { style: { display: 'none' } });
        };
        return ReactContent;
    }(react.PureComponent));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * A React component that can render a component and its children as other component types.
     */
    var Disguise = /** @class */ (function (_super) {
        __extends(Disguise, _super);
        function Disguise() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Disguise.prototype.render = function () {
            var _a = this.props, disguiseRootAs = _a.disguiseRootAs, disguiseChildrenAs = _a.disguiseChildrenAs, children = _a.children, ngChildComponents = _a.ngChildComponents, rest = __rest(_a, ["disguiseRootAs", "disguiseChildrenAs", "children", "ngChildComponents"]);
            var Root = disguiseRootAs || react.Fragment;
            var renderedChildren = ngChildComponents
                ? this._isReactContentOnlyChild()
                    ? this._renderReactContentChildren()
                    : this._renderChildrenNaive()
                : children;
            return react.createElement(Root, rest || null, renderedChildren);
        };
        Disguise.prototype._isReactContentOnlyChild = function () {
            var children = this.props.children;
            if (react.Children.count(children) === 1) {
                var _a = __read(react.Children.toArray(children), 1), onlyChild = _a[0];
                if (typeof onlyChild === 'object' && onlyChild.type === ReactContent) {
                    return true;
                }
            }
            return false;
        };
        Disguise.prototype._renderReactContentChildren = function () {
            var _a = this.props, ngChildComponents = _a.ngChildComponents, disguiseChildrenAs = _a.disguiseChildrenAs;
            var renderedChildren = ngChildComponents.map(function (child, index) {
                var propsToPass = removeUndefinedProperties(getPassProps(child).reduce(function (acc, passProp) {
                    var _a;
                    return Object.assign(acc, (_a = {}, _a[passProp.targetKey] = child[passProp.sourceKey], _a));
                }, {}));
                return react.createElement(disguiseChildrenAs, __assign({}, propsToPass, { key: index, ref: function (childReactElement) {
                        // ref callback is called with null when the component unmounts from the DOM, we don't need to handle it.
                        if (!childReactElement) {
                            return;
                        }
                        reactDom.findDOMNode(childReactElement).appendChild(child.elementRef.nativeElement);
                    } }));
            });
            return renderedChildren;
        };
        Disguise.prototype._renderChildrenNaive = function () {
            var _a = this.props, children = _a.children, disguiseChildrenAs = _a.disguiseChildrenAs;
            var renderedChildren = react.Children.map(children, function (child) {
                if (!disguiseChildrenAs || typeof child !== 'object') {
                    return child;
                }
                var ChildRoot = child.type || disguiseChildrenAs;
                return react.createElement(ChildRoot, __assign({}, child.props, { key: child.key }), child);
            });
            return renderedChildren;
        };
        return Disguise;
    }(react.PureComponent));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    var elementMap = new Map();
    var camelCaseSplit = /([a-z0-9])([A-Z])/g;
    /**
     * Register an element to be renderer when the renderer sees the tag.
     * @param elementName the tag to be used to get the component type when rendering.
     * @param resolver A resolver to the React component.
     */
    function registerElement(elementName, resolver) {
        if (elementMap.has(elementName)) {
            // Ignore multiple register attempts for the same component.
            // Angular doesn't allow sharing whole NgModule instances (in this case, an @NgModule for React-wrapped components) with lazy-loaded @NgModules (in the app),
            // To keep the API simple, allow multiple calls to `registerElement`.
            // Disadvantage is that you can't replace (React) component implementations at runtime. This sounds far-fetched, but solvable with a `static forRoot()` pattern for every
            // React-wrapper components' @NgModule, ensuring that `registerElement` is only called once.
            return;
        }
        else {
            var entry = { resolver: resolver };
            elementMap.set(elementName, entry);
            elementMap.set(elementName.toLowerCase(), entry);
            elementMap.set(elementName.replace(camelCaseSplit, '$1-$2').toLowerCase(), entry);
        }
    }
    function getComponentClass(elementName) {
        var entry = elementMap.get(elementName) || elementMap.get(elementName.toLowerCase());
        if (!entry) {
            // throw new TypeError(`No known component for element ${elementName}.`);
            return elementName;
        }
        try {
            return entry.resolver();
        }
        catch (e) {
            throw new TypeError("Could not load component for: " + elementName + "." + e);
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    function isReactNode(node) {
        return node.setRenderPendingCallback !== undefined;
    }
    /**
     * Logical representation of everything needed to render a React element in the
     * DOM, with the needed methods to do so.
     */
    var ReactNode = /** @class */ (function () {
        function ReactNode(type) {
            this.type = type;
            // Access to these properties are restricted through setters and functions
            // so that the dirty "render pending" state of this object can be properly
            // tracked and all nodes with "render pending" can be flushed at the end
            // of a render operation.
            this._props = {};
            this._children = [];
            this._childrenToAppend = [];
            this._isDestroyPending = false;
            this._isRenderPending = true;
            this.setRenderPendingCallback = function () { return null; };
            this.setRenderPending();
            this._tryResolveTypeIsReactElementClass();
        }
        Object.defineProperty(ReactNode.prototype, "domElement", {
            get: function () {
                return this._renderedDomElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReactNode.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            set: function (parent) {
                this._parent = parent;
                this.setRenderPending();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReactNode.prototype, "shouldRender", {
            get: function () {
                return !this._isNotRenderable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReactNode.prototype, "destroyPending", {
            get: function () {
                return this._isDestroyPending;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Track all pending render operations internally and set flag on
         * renderer factory so that a flush operation can be scheduled for
         * the "end" of render.
         */
        ReactNode.prototype.setRenderPending = function () {
            this.setRenderPendingCallback();
            this._isRenderPending = true;
        };
        /**
         * Marks the node to be removed from the DOM in the next render cycle.
         */
        ReactNode.prototype.destroyNode = function () {
            this.setRenderPending();
            this._isDestroyPending = true;
        };
        /**
         * Sets an attribute on the node.
         * @note the value can only be a `string`. See `setProperty` for other use-cases.
         * @see `Renderer2#setAttribute`.
         *
         * @param name The attribute name.
         * @param value The new value.
         */
        ReactNode.prototype.setAttribute = function (name, value) {
            var _a;
            this.setAttributes((_a = {}, _a[name] = value, _a));
        };
        /**
         * Set attributes on this node.
         * Note that values can only be of type `string`. See `setProperties` for other use-cases.
         * @see `Renderer2#setAttribute`.
         *
         * @param attributes the attributes to set.
         */
        ReactNode.prototype.setAttributes = function (attributes) {
            this.setProperties(attributes);
        };
        /**
         * Sets a prop in the underlying React element.
         * @see `Renderer2#setProperty`.
         *
         * @param name The property name.
         * @param value The new value.
         */
        ReactNode.prototype.setProperty = function (name, value) {
            var _a;
            this.setProperties((_a = {}, _a[name] = value, _a));
        };
        /**
         * Like `setProperty` but for multiple props at once.
         *
         * @param properties An object with the props.
         */
        ReactNode.prototype.setProperties = function (properties) {
            this.setRenderPending();
            Object.assign(this._props, removeUndefinedProperties(properties));
        };
        /**
         * Remove a prop or an attribute from the underlying React element.
         * @see `Renderer2#removeAttribute`.
         *
         * @param name The property name.
         * @param childName _Optional_ A property of `name` to remove instead.
         * @returns the deleted property
         */
        ReactNode.prototype.removeProperty = function (name, childName) {
            this.setRenderPending();
            if (childName) {
                return delete this._props[name][childName];
            }
            return delete this._props[name];
        };
        /**
         * Add a direct child of this node.
         * @see `Renderer2#addChild`.
         *
         * @param node The node to add.
         */
        ReactNode.prototype.addChild = function (node) {
            this.setRenderPending();
            this._children.push(node);
        };
        /**
         * Remove a direct child of this node.
         * @see `Renderer2#removeChild`.
         *
         * @param node The node to remove.
         */
        ReactNode.prototype.removeChild = function (node) {
            this.setRenderPending();
            this._children = this._children.filter(function (child) { return child !== node; });
        };
        /**
         * Cast the node to a comment node.
         * @see `Renderer2#createComment`.
         *
         * @param value the text in the comment to render.
         * @returns itself.
         */
        ReactNode.prototype.asComment = function (value) {
            this.setRenderPending();
            this.type = undefined;
            this._comment = value;
            return this;
        };
        /**
         * Cast the node to a text node.
         * @see `Renderer2#createText`.
         *
         * @param value the text to render.
         * @returns itself.
         */
        ReactNode.prototype.asText = function (value) {
            this.setRenderPending();
            this.type = undefined;
            this._text = value;
            // Skip appending and rendering of empty text nodes. This may cause a bug
            // if a single space is desired...
            if (!value || !value.trim()) {
                this._isNotRenderable = true;
            }
            return this;
        };
        /**
         * Render the node to the DOM, or unmount it, as necessary.
         *
         * @returns itself.
         */
        ReactNode.prototype.render = function () {
            // Only complete render operations for ReactNodes that are parented by HTMLElements.
            // Those that are parented by other ReactNodes will be rendered recursively by their
            // parent.
            if (!isReactNode(this._parent)) {
                if (this._isDestroyPending && this._parent) {
                    reactDom.unmountComponentAtNode(this._parent);
                    return this;
                }
                if (this._isRenderPending) {
                    // It is expected that the element will be recreated and re-rendered with each attribute change.
                    // See: https://reactjs.org/docs/rendering-elements.html
                    reactDom.render(this._renderRecursive(), this._parent);
                    this._isRenderPending = false;
                }
            }
            return this;
        };
        /**
         * Appends a child.
         *
         * @see `Renderer2#appendChild`.
         * @note This is called by Angular core when projected content is being added.
         *
         * @param projectedContent the content to project.
         */
        ReactNode.prototype.appendChild = function (projectedContent) {
            this._childrenToAppend.push(projectedContent);
        };
        /**
         * @note for easier debugging.
         */
        ReactNode.prototype.toString = function () {
            if (this._typeName) {
                return "[" + this._typeName + " ReactNode]";
            }
            if (this._text) {
                return '[text ReactNode]';
            }
            if (this._comment) {
                return '[comment ReactNode]';
            }
            return '[undefined ReactNode]';
        };
        ReactNode.prototype._renderRecursive = function (key) {
            var children = this._children
                ? this._children.map(function (child, index) { return child._renderRecursive(index.toString()); })
                : [];
            if (this._text) {
                return this._text;
            }
            this._props[CHILDREN_TO_APPEND_PROP] = this._childrenToAppend;
            if (key) {
                this._props['key'] = key;
            }
            // Just having some props on a React element can cause it to
            // behave undesirably, and since the templates are hard-coded to pass
            // all Inputs all the time, they pass `undefined` values too.
            // This ensures these are removed.
            // Additionally, there are some things that Angular templating forbids,
            // and stops at-compile time (with errors), such as `Input`s being prefixed with `on`.
            // Since React does not have the notion of `Output`s as Angular (they are just props of type function, essentially callbacks).
            // To work around this, we, by convention, prefix any PascalCased prop with `on` here, after the template has already been compiled.
            var clearedProps = this._transformProps(removeUndefinedProperties(this._props));
            return react.createElement(this.type, clearedProps, children.length > 0 ? children : undefined);
        };
        ReactNode.prototype._transformProps = function (props) {
            var _this = this;
            return Object.entries(props).reduce(function (acc, _a) {
                var _b;
                var _c = __read(_a, 2), key = _c[0], value = _c[1];
                var _d = __read(typeof key !== 'string' ? [key, value] : _this._transformProp(key, value), 2), newKey = _d[0], newValue = _d[1];
                return Object.assign(acc, (_b = {}, _b[newKey] = newValue, _b));
            }, {});
        };
        ReactNode.prototype._transformProp = function (name, value) {
            // prop name is camelCased already
            var firstLetter = name[0];
            if (firstLetter === firstLetter.toLowerCase()) {
                return [name, value];
            }
            // prop name is PascalCased & is a function - assuming render prop or callback prop that has return value
            // NOTE: Angular doesn't allow passing @Inputs that are prefixed with "on". This is useful for render props and properties representing the "on" state (for example, Toggle).
            // As a convention, any @Input that starts with a capital letter is prefixed with "on" when passed as a prop to the underlying React component.
            return ["on" + name, value];
        };
        ReactNode.prototype._tryResolveTypeIsReactElementClass = function () {
            if (this._typeIsReactElementClass === undefined) {
                // Comments and text have no type.
                if (!this.type) {
                    return;
                }
                // Store the name of the type for the toString message (debugging).
                this._typeName = this.type;
                // Attempt to resolve the type as a React Element class name/type.
                // Since Angular templates are just strings, we can't include types in them.
                // Therefore, we use the component registry to resolve the type of a component from a string.
                if (typeof this.type === 'string') {
                    this.type = getComponentClass(this.type);
                }
                // If type is still a string, then no React Element matches this string.
                this._typeIsReactElementClass = typeof this.type !== 'string';
            }
        };
        return ReactNode;
    }());

    /**
     * Monkey-patches `Element`'s `addEventListener` & `removeEventListener` and adds `getEventListeners`.
     * This later allows the renderer to emit any event handlers attached to React-wrapped components as Angular Outputs:
     * ```html
     * <my-component (arbitraryEvent)="onEventHandler($event)"></my-component>
     * ```
     *
     * @note Taken and modified from https://github.com/colxi/getEventListeners to be compiled into ES5, allowing running in older browsers
     **/
    Element.prototype['_addEventListener'] = Element.prototype.addEventListener;
    Element.prototype['_removeEventListener'] = Element.prototype.removeEventListener;
    Element.prototype.addEventListener = function (type, listener, options) {
        if (options === undefined)
            options = false;
        // declare listener
        this._addEventListener(type, listener, options);
        if (!this.eventListenerList)
            this.eventListenerList = {};
        if (!this.eventListenerList[type])
            this.eventListenerList[type] = [];
        // add listener to  event tracking list
        this.eventListenerList[type].push({
            type: type,
            listener: listener,
            useCapture: options,
        });
    };
    Element.prototype.removeEventListener = function (type, listener, options) {
        if (options === undefined)
            options = false;
        // remove listener
        this._removeEventListener(type, listener, options);
        if (!this.eventListenerList)
            this.eventListenerList = {};
        if (!this.eventListenerList[type])
            this.eventListenerList[type] = [];
        // Find the event in the list, If a listener is registered twice, one
        // with capture and one without, remove each one separately. Removal of
        // a capturing listener does not affect a non-capturing version of the
        // same listener, and vice versa.
        for (var i = 0; i < this.eventListenerList[type].length; i++) {
            if (this.eventListenerList[type][i].listener === listener &&
                this.eventListenerList[type][i].useCapture === options) {
                this.eventListenerList[type].splice(i, 1);
                break;
            }
        }
        // if no more events of the removed event type are left,remove the group
        if (this.eventListenerList[type].length == 0)
            delete this.eventListenerList[type];
    };
    Element.prototype.getEventListeners = function (type) {
        if (!this.eventListenerList)
            this.eventListenerList = {};
        // return requested listeners type or all them
        if (type === undefined)
            return this.eventListenerList;
        return this.eventListenerList[type];
    };
    /*
        Element.prototype.clearEventListeners = function(a){
            if(!this.eventListenerList)
                this.eventListenerList = {};
            if(a==undefined){
                for(var x in (this.getEventListeners())) this.clearEventListeners(x);
                return;
            }
            var el = this.getEventListeners(a);
            if(el==undefined)
                return;
            for(var i = el.length - 1; i >= 0; --i) {
                var ev = el[i];
                this.removeEventListener(a, ev.listener, ev.useCapture);
            }
        };
        */

    // Copyright (c) Microsoft Corporation. All rights reserved.
    var AngularReactRendererFactory = /** @class */ (function (_super) {
        __extends(AngularReactRendererFactory, _super);
        function AngularReactRendererFactory(eventManager, sharedStylesHost) {
            var _this = _super.call(this, eventManager, sharedStylesHost, 'app-id') || this;
            // Collection of ReactNodes that can be evaluated and flushed at the
            // end of Render.  This is necessary as the flow of element creation
            // and update goes from "create" > "insert" > "update" property/attribute.
            // React elements cannot be "inserted" and later have their props
            // updated, so the "insert", or React.Render, can only be done once the
            // element has been fully defined.  Only the topmost [root] nodes are added here.
            _this.reactRootNodes = new Set();
            // This flag can only be set to true from outside.  It can only be reset
            // to false from inside.  This value is reset on "end" when the pending
            // renders are flushed.
            _this.setRenderPendingCallback = function () {
                _this.isRenderPending = true;
            };
            // tslint:disable-next-line: no-use-before-declare
            _this.defaultReactRenderer = new ReactRenderer(_this);
            return _this;
        }
        AngularReactRendererFactory.prototype.createRenderer = function (element, type) {
            if (type && type.styles.length && type.styles[0] === 'react-renderer') {
                return this.defaultReactRenderer;
            }
            return _super.prototype.createRenderer.call(this, element, type);
        };
        AngularReactRendererFactory.prototype.begin = function () { };
        AngularReactRendererFactory.prototype.end = function () {
            // Flush any pending React element render updates.  This cannot be done
            // earlier (as is done for DOM elements) because React element props
            // are ReadOnly.
            if (this.isRenderPending) {
                // Remove root nodes that are pending destroy after render.
                this.reactRootNodes = new Set(Array.from(this.reactRootNodes).filter(function (node) { return !node.render().destroyPending; }));
                this.isRenderPending = false;
            }
        };
        AngularReactRendererFactory = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [platformBrowser.EventManager, platformBrowser.ɵDomSharedStylesHost])
        ], AngularReactRendererFactory);
        return AngularReactRendererFactory;
    }(platformBrowser.ɵDomRendererFactory2));
    var isReactRendererData = function (data) {
        return data && typeof data.addRootNode === 'function';
    };
    var ReactRenderer = /** @class */ (function () {
        function ReactRenderer(rootRenderer) {
            var _this = this;
            this.rootRenderer = rootRenderer;
            this.data = {
                addRootNode: function (node) {
                    _this.rootRenderer.reactRootNodes.add(node);
                },
            };
            // These two elements are essential for the whole experience to be smooth for the user - register them from the get-go.
            registerElement('ReactContent', function () { return ReactContent; });
            registerElement('Disguise', function () { return Disguise; });
        }
        ReactRenderer.prototype.destroy = function () { };
        ReactRenderer.prototype.destroyNode = function (node) {
            node.destroyNode();
        };
        ReactRenderer.prototype.createElement = function (name, namespace) {
            return new ReactNode(name);
        };
        ReactRenderer.prototype.createComment = function (value) {
            return new ReactNode().asComment(value);
        };
        ReactRenderer.prototype.createText = function (value) {
            return new ReactNode().asText(value);
        };
        ReactRenderer.prototype.appendChild = function (parent, node) {
            // Only append a child if there is a child to append.
            if (!node) {
                return;
            }
            // Don't append empty text nodes.
            if (!node.shouldRender) {
                return;
            }
            // Provide a parent element reference to the ReactNode.  This will be used later
            // once the ReactNode is fully defined and it is subsequently rendered.
            if (!isReactNode(parent)) {
                node.setRenderPendingCallback = this.rootRenderer.setRenderPendingCallback;
                this.rootRenderer.reactRootNodes.add(node);
                node.parent = parent;
                return;
            }
            node.setRenderPendingCallback = function () { return parent.setRenderPending(); };
            parent.addChild(node);
            node.parent = parent;
        };
        ReactRenderer.prototype.insertBefore = function (parent, node, refChild) {
            // Only insert a child if there is a parent.
            if (!parent) {
                return;
            }
            var target = document.createElement('div');
            parent.insertBefore(target, refChild);
            node.parent = target;
            node.setRenderPendingCallback = this.rootRenderer.setRenderPendingCallback;
        };
        ReactRenderer.prototype.removeChild = function (parent, node) {
            // Only insert a child if there is a parent.
            if (!parent) {
                return;
            }
            // Remove a parent element reference from the ReactNode.  This will be later
            // result in the ReactNode unloading itself.
            if (!isReactNode(parent)) {
                node.parent = null;
                return;
            }
            parent.removeChild(node);
        };
        ReactRenderer.prototype.selectRootElement = function (selectorOrNode) {
        };
        ReactRenderer.prototype.parentNode = function (node) {
        };
        ReactRenderer.prototype.nextSibling = function (node) {
        };
        ReactRenderer.prototype.setAttribute = function (node, name, value, namespace) {
            node.setProperty(name, value);
        };
        ReactRenderer.prototype.removeAttribute = function (node, name, namespace) {
            node.removeProperty(name);
        };
        ReactRenderer.prototype.addClass = function (node, name) {
            // Update the virtual node.
            // TODO: This may only support a single class name, but might work if property name is a single
            //       comma-delimited list of classes...
            node.setProperty('className', name);
        };
        ReactRenderer.prototype.removeClass = function (node, name) {
            // Update the virtual node.
            // TODO: This may not work correctly to remove a single name from a comma-delimited list.
            node.removeProperty('className');
        };
        ReactRenderer.prototype.setStyle = function (node, style, value, flags) {
            // if (DEBUG) { console.log('Renderer > setStyle > node: ', node.toString(), 'style:', style, 'value:', value, 'flags:', flags); }
            if (flags & core.RendererStyleFlags2.DashCase) {
                node.setProperty('style', { style: value + !!(flags & core.RendererStyleFlags2.Important) ? ' !important' : '' });
            }
            else {
                node.setProperty('style', { style: value });
            }
        };
        ReactRenderer.prototype.removeStyle = function (node, style, flags) {
            node.removeProperty('style', style);
        };
        ReactRenderer.prototype.setProperty = function (node, name, value) {
            node.setProperty(name, value);
        };
        ReactRenderer.prototype.setValue = function (node, value) {
            node.setProperty('value', value);
        };
        ReactRenderer.prototype.listen = function (target, event, callback) {
            target.setProperty(event, callback);
            // TODO: NEEDS WORK: Implement prevent default callback behavior.
            // return <() => void>this.eventManager.addEventListener(
            //            target, event, decoratePreventDefault(callback)) as() => void;
            // tslint:disable-next-line:no-unused-expression
            return function () { return null; };
        };
        return ReactRenderer;
    }());

    // Copyright (c) Microsoft Corporation. All rights reserved.
    var AngularReactBrowserModule = /** @class */ (function () {
        function AngularReactBrowserModule() {
        }
        AngularReactBrowserModule = __decorate([
            core.NgModule({
                imports: [platformBrowser.BrowserModule],
                exports: [platformBrowser.BrowserModule],
                providers: [{ provide: platformBrowser.ɵDomRendererFactory2, useClass: AngularReactRendererFactory }],
            })
        ], AngularReactBrowserModule);
        return AngularReactBrowserModule;
    }());

    /**
     * Transforms an array of [key, value] tuples to an object
     */
    function toObject(pairs) {
        return pairs.reduce(function (acc, _a) {
            var _b;
            var _c = __read(_a, 2), key = _c[0], value = _c[1];
            return Object.assign(acc, (_b = {},
                _b[key] = value,
                _b));
        }, {});
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    /**
     * Delays the execution of a function to be after the next render.
     *
     * @param callback The function to execute
     */
    var afterRenderFinished = function (callback) {
        setTimeout(callback, 0);
    };

    // Copyright (c) Microsoft Corporation. All rights reserved.
    var TEMPLATE_DETECT_CHANGES_THROTTLE_MS = 250;
    /**
     * Creates a new `ReactTemplate` element.
     * @param templateRef The template to render.
     * @param context The context to inject the template.
     * @param ngZone A zone used for tracking changes in the template.
     * @param additionalProps _Optional_. @see `ReactTemplateProps`.
     */
    function createReactTemplateElement(templateRef, context, ngZone, additionalProps) {
        return react.createElement(ReactTemplate, __assign({ ngZone: ngZone, templateRef: templateRef, context: context }, additionalProps));
    }
    /**
     * Render an `ng-template` as a child of a React component.
     * Supports two rendering modes:
     *  1. `legacy` - append `<react-content>` as the root, and nest the `children-to-append` underneath it.
     *  2. `new` (**default**) - append the `children-to-append` to the parent of this component, and hide the `<react-content>` element.
     *     (similar to how `router-outlet` behaves in Angular).
     */
    var ReactTemplate = /** @class */ (function (_super) {
        __extends(ReactTemplate, _super);
        function ReactTemplate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ReactTemplate.prototype.componentDidUpdate = function () {
            // Context has changes, trigger change detection after pushing the new context in
            if (this.props.context != null && this._embeddedViewRef.context != null) {
                Object.assign(this._embeddedViewRef.context, this.props.context);
            }
            this._embeddedViewRef.detectChanges();
        };
        ReactTemplate.prototype.componentDidMount = function () {
            var _this = this;
            var _a = this.props, context = _a.context, ngZone = _a.ngZone, templateRef = _a.templateRef;
            this._embeddedViewRef = templateRef.createEmbeddedView(context);
            var element = reactDom.findDOMNode(this);
            var hostElement = this.props.legacyRenderMode ? element : element.parentElement;
            this._embeddedViewRef.rootNodes.forEach(function (child) { return hostElement.appendChild(child); });
            // Detect the first cycle's changes, and then subscribe for subsequent ones.
            this._embeddedViewRef.detectChanges();
            // Throttling the detect changes to an empirically selected value so we don't overload too much work.
            // TODO: This needs some better solution to listen to changes to the binding sources of the template.
            this._ngZoneSubscription = ngZone.onStable
                .pipe(operators.throttleTime(TEMPLATE_DETECT_CHANGES_THROTTLE_MS, undefined, { leading: true, trailing: true }))
                .subscribe(function () {
                _this._embeddedViewRef.detectChanges();
            });
        };
        ReactTemplate.prototype.componentWillUnmount = function () {
            this._ngZoneSubscription.unsubscribe();
            if (this._embeddedViewRef) {
                this._embeddedViewRef.destroy();
            }
        };
        ReactTemplate.prototype.render = function () {
            // TODO: See if we can just render React.Fragment and the children within it, having no extra DOM nodes.
            return react.createElement('react-template', !this.props.legacyRenderMode && { style: { display: 'none' } });
        };
        return ReactTemplate;
    }(react.Component));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    function isRenderPropContext(x) {
        if (typeof x !== 'object') {
            return false;
        }
        var maybeRenderPropContext = x;
        return maybeRenderPropContext.render && typeof maybeRenderPropContext.render === 'function';
    }
    function renderReactContent(rootNodes, additionalProps) {
        return createReactContentElement(rootNodes, additionalProps);
    }
    /**
     * Wrap a `TemplateRef` with a `JSX.Element`.
     *
     * @param templateRef The template to wrap
     * @param ngZone A zone used for tracking & triggering updates to the template
     * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
     */
    function createTemplateRenderer(templateRef, ngZone, additionalProps) {
        return {
            render: function (context) { return createReactTemplateElement(templateRef, context, ngZone, additionalProps); },
        };
    }
    /**
     * Wrap a function resolving to an `HTMLElement` with a `JSX.Element`.
     *
     * @param htmlRenderFunc The function to wrap
     * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
     */
    function createHtmlRenderer(htmlRenderFunc, additionalProps) {
        return {
            render: function (context) {
                var rootHtmlElement = htmlRenderFunc(context);
                return renderReactContent([rootHtmlElement], additionalProps);
            },
        };
    }
    /**
     * Wrap a `ComponentRef` with a `JSX.Element`.
     *
     * @param htmlRenderFunc The component reference to wrap
     * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
     */
    function createComponentRenderer(componentRef, additionalProps) {
        var renderedJsx = null;
        return {
            render: function (context) {
                if (!renderedJsx) {
                    renderedJsx = renderReactContent([componentRef.location.nativeElement], additionalProps);
                }
                Object.assign(componentRef.instance, context);
                componentRef.changeDetectorRef.detectChanges();
                return renderedJsx;
            },
        };
    }

    function isRenderComponentOptions(x) {
        if (typeof x !== 'object') {
            return false;
        }
        var maybeRenderComponentOptions = x;
        return (maybeRenderComponentOptions.componentType != null &&
            maybeRenderComponentOptions.factoryResolver != null &&
            maybeRenderComponentOptions.injector != null);
    }
    function isRenderPropOptions(x) {
        if (typeof x !== 'object') {
            return false;
        }
        var maybeRenderPropOptions = x;
        return maybeRenderPropOptions.getProps && typeof maybeRenderPropOptions.getProps === 'function';
    }
    function createInputJsxRenderer(input, ngZone, additionalProps) {
        if (input instanceof core.TemplateRef) {
            var templateRenderer_1 = createTemplateRenderer(input, ngZone, additionalProps);
            return function (context) { return templateRenderer_1.render(context); };
        }
        if (input instanceof core.ComponentRef) {
            var componentRenderer_1 = createComponentRenderer(input, additionalProps);
            return function (context) { return componentRenderer_1.render(context); };
        }
        if (input instanceof Function) {
            var htmlRenderer_1 = createHtmlRenderer(input, additionalProps);
            return function (context) { return htmlRenderer_1.render(context); };
        }
        if (isRenderComponentOptions(input)) {
            var componentType = input.componentType, factoryResolver = input.factoryResolver, injector = input.injector;
            var componentFactory = factoryResolver.resolveComponentFactory(componentType);
            var componentRef = componentFactory.create(injector);
            // Call the function again with the created ComponentRef<TContext>
            return createInputJsxRenderer(componentRef, ngZone, additionalProps);
        }
    }
    function createRenderPropHandler(renderInputValue, ngZone, options) {
        if (isRenderPropContext(renderInputValue)) {
            return renderInputValue.render;
        }
        if (isRenderPropOptions(renderInputValue)) {
            return function (props, defaultRender) {
                return typeof defaultRender === 'function' ? defaultRender(renderInputValue.getProps(props)) : null;
            };
        }
        var renderer = (options && options.jsxRenderer) ||
            createInputJsxRenderer(renderInputValue, ngZone, options && options.additionalProps);
        return function (props, defaultRender) {
            if (!renderInputValue) {
                return typeof defaultRender === 'function' ? defaultRender(props) : null;
            }
            return renderer(props);
        };
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Forbidden attributes are still ignored, since they may be set from the wrapper components themselves (forbidden is only applied for users of the wrapper components)
    var ignoredAttributeMatchers = [/^_?ng-?.*/, /^style$/, /^class$/];
    var ngClassRegExp = /^ng-/;
    var defaultWrapperComponentOptions = {
        setHostDisplay: false,
    };
    /**
     * Base class for Angular @Components wrapping React Components.
     * Simplifies some of the handling around passing down props and CSS styling on the host component.
     */
    // NOTE: TProps is not used at the moment, but a preparation for a potential future change.
    var ReactWrapperComponent = /** @class */ (function () {
        /**
         * Creates an instance of ReactWrapperComponent.
         * @param elementRef The host element.
         * @param changeDetectorRef The change detector for the component.
         * @param renderer The Angular renderer.
         */
        function ReactWrapperComponent(elementRef, changeDetectorRef, renderer, _a) {
            var _b = _a === void 0 ? defaultWrapperComponentOptions : _a, setHostDisplay = _b.setHostDisplay, ngZone = _b.ngZone;
            this.elementRef = elementRef;
            this.changeDetectorRef = changeDetectorRef;
            this.renderer = renderer;
            this._ngZone = ngZone;
            this._shouldSetHostDisplay = setHostDisplay;
        }
        Object.defineProperty(ReactWrapperComponent.prototype, "contentClass", {
            get: function () {
                return this._contentClass;
            },
            /**
             * Alternative to `class` and `[ngClass]` using the same syntax.
             *
             * @description Since this is a wrapper component, sticking to the virtual DOM concept, its DOM element shouldn't have any styling of its own.
             * Instead, any value passes to `contentClass` will be passed to the root component's class as `className`.
             */
            set: function (value) {
                this._contentClass = value;
                if (isReactNode(this.reactNodeRef.nativeElement)) {
                    this.reactNodeRef.nativeElement.setProperty('className', classnames(value));
                    this.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReactWrapperComponent.prototype, "contentStyle", {
            get: function () {
                return this._contentStyle;
            },
            /**
             * Alternative to `style` and `[ngStyle]` using (almost) the same syntax.
             * All syntax supports by `ngStyle` is supported, with the exception of specifying units in the key (`{ 'width.px': 12 }`).
             *
             * @description Since this is a wrapper component, sticking to the virtual DOM concept, this should have any styling of its own.
             * Any value passes to `contentStyle` will be passed to the root component's style.
             */
            set: function (value) {
                this._contentStyle = value;
                if (isReactNode(this.reactNodeRef.nativeElement)) {
                    var stringValue = typeof value === 'string' ? value : stylenames(value);
                    this.reactNodeRef.nativeElement.setProperty('style', toStyle(stringValue));
                    this.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        ReactWrapperComponent.prototype.ngAfterContentInit = function () {
            this._passAttributesAsProps();
        };
        ReactWrapperComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this._shouldSetHostDisplay) {
                this._setHostDisplay();
            }
            // NOTE: Workaround/fix for Issue #5 (https://github.com/Microsoft/angular-react/issues/5).
            // The wrapper component isn't added to the root react nodes list when it's inside a `ReactContent` node, we manually add it (note that the root nodes list is a `Set`, so it won't duplicate nodes if already exist).
            // There's potentially a better solution instead of this
            var rendererData = this.renderer.data;
            if (isReactRendererData(rendererData)) {
                afterRenderFinished(function () {
                    var nativeElement = _this.reactNodeRef.nativeElement;
                    if (isReactNode(nativeElement)) {
                        rendererData.addRootNode(nativeElement);
                    }
                });
            }
        };
        ReactWrapperComponent.prototype.ngOnChanges = function (changes) {
            this._passAttributesAsProps();
            this.markForCheck();
        };
        /**
         * Mark the component as one that needed re-rendering on the React side,
         * and mark for change detection on the Angular side.
         */
        ReactWrapperComponent.prototype.markForCheck = function () {
            if (isReactNode(this.reactNodeRef.nativeElement)) {
                this.reactNodeRef.nativeElement.setRenderPending();
            }
            this.changeDetectorRef.markForCheck();
        };
        /**
         * Create an JSX renderer for an `@Input` property.
         * @param input The input property.
         * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
         */
        ReactWrapperComponent.prototype.createInputJsxRenderer = function (input, additionalProps) {
            if (input === undefined) {
                return undefined;
            }
            if (!this._ngZone) {
                throw new Error('To create an input JSX renderer you must pass an NgZone to the constructor.');
            }
            return createInputJsxRenderer(input, this._ngZone, additionalProps);
        };
        /**
         * Create an event handler for a render prop
         * @param renderInputValue the value of the render `@Input` property.
         * @param jsxRenderer an optional renderer to use.
         * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
         */
        ReactWrapperComponent.prototype.createRenderPropHandler = function (renderInputValue, options) {
            return createRenderPropHandler(renderInputValue, this._ngZone, options);
        };
        ReactWrapperComponent.prototype._passAttributesAsProps = function () {
            var _this = this;
            var hostAttributes = Array.from(this.elementRef.nativeElement.attributes);
            if (!this.reactNodeRef || !isReactNode(this.reactNodeRef.nativeElement)) {
                throw new Error('reactNodeRef must hold a reference to a ReactNode');
            }
            // Ensure there are no blacklisted props. Suggest alternative as error if there is any
            hostAttributes.forEach(function (attr) {
                var _a = __read(_this._isForbiddenAttribute(attr), 2), forbidden = _a[0], alternativeAttrName = _a[1];
                if (forbidden) {
                    throw new Error("[" + _this.elementRef
                        .nativeElement.tagName.toLowerCase() + "] React wrapper components cannot have the '" + attr.name + "' attribute set. Use the following alternative: " + (alternativeAttrName || ''));
                }
            });
            var whitelistedHostAttributes = hostAttributes.filter(function (attr) { return !_this._isIgnoredAttribute(attr); });
            var props = whitelistedHostAttributes.reduce(function (acc, attr) {
                var _a;
                return (__assign({}, acc, (_a = {}, _a[attr.name] = attr.value, _a)));
            }, {});
            var eventListeners = this.elementRef.nativeElement.getEventListeners();
            var eventHandlersProps = eventListeners && Object.keys(eventListeners).length
                ? toObject(Object.values(eventListeners).map(function (_a) {
                    var _b = __read(_a, 1), eventListener = _b[0];
                    return [
                        eventListener.type,
                        function (ev) { return eventListener.listener(ev && ev.nativeEvent); },
                    ];
                }))
                : {};
            this.reactNodeRef.nativeElement.setProperties(__assign({}, props, eventHandlersProps));
        };
        ReactWrapperComponent.prototype._setHostDisplay = function () {
            var nativeElement = this.elementRef.nativeElement;
            // We want to wait until child elements are rendered
            requestAnimationFrame(function () {
                if (nativeElement.firstElementChild) {
                    var rootChildDisplay = getComputedStyle(nativeElement.firstElementChild).display;
                    nativeElement.style.display = rootChildDisplay;
                }
            });
        };
        ReactWrapperComponent.prototype._isIgnoredAttribute = function (attr) {
            return ignoredAttributeMatchers.some(function (regExp) { return regExp.test(attr.name); });
        };
        ReactWrapperComponent.prototype._isForbiddenAttribute = function (attr) {
            var name = attr.name, value = attr.value;
            if (name === 'key')
                return [true, undefined];
            if (name === 'class' && value.split(' ').some(function (className) { return !ngClassRegExp.test(className); }))
                return [true, 'contentClass'];
            if (name === 'style') {
                var style = toStyle(value);
                // Only allowing style if it's something that changes the display - setting anything else should be done on the child component directly (via the `styles` attribute in fabric for example)
                if (Object.entries(style).filter(function (_a) {
                    var _b = __read(_a, 2), key = _b[0], value = _b[1];
                    return value && key !== 'display';
                }).length > 0) {
                    return [true, 'contentStyle'];
                }
            }
            return [false, undefined];
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], ReactWrapperComponent.prototype, "contentClass", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], ReactWrapperComponent.prototype, "contentStyle", null);
        return ReactWrapperComponent;
    }());

    exports.AngularReactBrowserModule = AngularReactBrowserModule;
    exports.Disguise = Disguise;
    exports.ReactContent = ReactContent;
    exports.ReactTemplate = ReactTemplate;
    exports.ReactWrapperComponent = ReactWrapperComponent;
    exports.createReactContentElement = createReactContentElement;
    exports.createReactTemplateElement = createReactTemplateElement;
    exports.getPassProps = getPassProps;
    exports.passProp = passProp;
    exports.registerElement = registerElement;
    exports.ɵa = passPropsSymbol;
    exports.ɵb = AngularReactRendererFactory;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=angular-react-core.umd.js.map
